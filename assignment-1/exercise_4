/*
Exercise 4


1. The call of same_spieces(dog,A) will fail because
all of the clause that appear in the KB, and might be accesed by the call of same_spieces(dog,A),
consist of the not(X=Y).
After binding the dog = X and A = Y we have not(dog=A), where A is uninstantiated variable and dog is an instance.
Therefroe dog=A is valid, however not(sth) evaluates to true only if sth = false, thus in this case not(dog=A)
will evaluate to false. The same case happens in the last clause where not(X=Y) is chekced again.


2. 
mammal( dog ).
mammal( cat ).
bird( eagle ).
bird( parrot ).
same_species(X ,Y ) :- mammal(X), mammal(Y), not(X=Y)
same_species(X , Y ) :- bird(X), bird(Y), not(X=Y)

If we change our KB to the one proivded above, query like same_spieces(dog, A) will succeed.
That is the case since after the call, X binds to the dog, and Y binds to the A 
Our KB further start looking for mammal(dog) and it finds one (making it true), and then 
start looking for mammal(A) finds mammal(dog) so binds A with dog (making it true as well).
Then it checks not(X=Y), since in our case we have dog = doge it makes this rule false.
It backtracks to the mammal(A) and checks if there is any other instance that might satisty this rule.
It finds mammal(cat) and it binds it with A (makes it true), then it proceeds to the last rule
where X has to be different from Y - if Y = cat, and X = dog that is the case, and it makes that rule true.




4.  
mammal( dog ).
mammal( cat ).
bird( eagle ).
bird( parrot ).
same_species(X ,Y ) :- mammal(X), mammal(Y), not(X=Y)
same_species(X , Y ) :- bird(X), bird(Y), not(X=Y)

This KB wil improve the performance of the cals such as same_species(X,Y). 
This is the fact since it doesnt' immedietly fails by checking the not(X=Y) (as it happended with the intial KB)
With the updated KB and with the intial call same_species(dog,A) it first, bounds X = dog and then Y = A
it then checks if the mammal(dog) exsits in our KB - it does. then it check if mammal(A) exists.
The first that occurs is when A = dog, thus this evaluates to true as well. Finally it checks 
not(X=Y) which in our case is (dog = dog)  = True but not(True) = False thus it backtracks to the 
previous step and checks the if there is any other value that could boudn to A and satisfy mammal(sth).
There is a value cat, it bounds to A = cat, we have mammal(cat) = true , and then not(dog=cat) = true 


*/

